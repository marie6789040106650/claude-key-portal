/**
 * APIÂØÜÈí•Âà†Èô§ÂäüËÉΩÊµãËØï
 * Sprint 2 - üî¥ RED Phase
 * @jest-environment node
 */

import { DELETE } from '@/app/api/keys/[id]/route'
import { prisma } from '@/lib/infrastructure/persistence/prisma'
import { crsClient } from '@/lib/infrastructure/external/crs-client'
import jwt from 'jsonwebtoken'

// Mock Prisma
jest.mock('@/lib/infrastructure/persistence/prisma', () => ({
  prisma: {
    apiKey: {
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
  },
}))

// Mock CRS Client
jest.mock('@/lib/infrastructure/external/crs-client', () => ({
  crsClient: {
    deleteKey: jest.fn(),
  },
}))

// Mock JWT
jest.mock('jsonwebtoken', () => ({
  verify: jest.fn(),
}))

describe('DELETE /api/keys/[id]', () => {
  const mockUserId = 'user_123'
  const mockAccessToken = 'valid_access_token'
  const mockKeyId = 'local_key_123'
  const mockCrsKeyId = 'crs_key_123'

  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe('‚úÖ ÊàêÂäüÂú∫ÊôØ', () => {
    it('Â∫îËØ•ÊàêÂäüÂà†Èô§APIÂØÜÈí•ÔºàËΩØÂà†Èô§Ôºâ', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'To Be Deleted',
        status: 'ACTIVE',
      }

      const deletedKey = {
        ...existingKey,
        status: 'DELETED',
        deletedAt: new Date(),
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockResolvedValue({ success: true })
      ;(prisma.apiKey.update as jest.Mock).mockResolvedValue(deletedKey)

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(200)
      expect(data).toHaveProperty('success', true)
      expect(data).toHaveProperty('message')

      // È™åËØÅÂÖàË∞ÉÁî®CRSÂà†Èô§
      expect(crsClient.deleteKey).toHaveBeenCalledWith(mockCrsKeyId)

      // È™åËØÅÊú¨Âú∞ËΩØÂà†Èô§
      expect(prisma.apiKey.update).toHaveBeenCalledWith({
        where: { id: mockKeyId },
        data: {
          status: 'DELETED',
        },
      })
    })

    it('Â∫îËØ•ÊàêÂäüÊ∞∏‰πÖÂà†Èô§APIÂØÜÈí•ÔºàÂº∫Âà∂Âà†Èô§Ôºâ', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'To Be Permanently Deleted',
        status: 'ACTIVE',
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockResolvedValue({ success: true })
      ;(prisma.apiKey.delete as jest.Mock).mockResolvedValue(existingKey)

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}?permanent=true`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(200)
      expect(data).toHaveProperty('success', true)

      // È™åËØÅÊ∞∏‰πÖÂà†Èô§
      expect(prisma.apiKey.delete).toHaveBeenCalledWith({
        where: { id: mockKeyId },
      })
    })

    it('Âà†Èô§Â∑≤Âà†Èô§ÁöÑÂØÜÈí•Â∫îËØ•ËøîÂõûÊàêÂäüÔºàÂπÇÁ≠âÊÄßÔºâ', async () => {
      // Arrange
      const deletedKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Already Deleted',
        status: 'DELETED',
        deletedAt: new Date('2025-01-01'),
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(deletedKey)

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(200)
      expect(data).toHaveProperty('success', true)
      expect(data).toHaveProperty('alreadyDeleted', true)
      expect(crsClient.deleteKey).not.toHaveBeenCalled()
      expect(prisma.apiKey.update).not.toHaveBeenCalled()
    })

    it('Â∫îËØ•ËøîÂõûÂà†Èô§Á°ÆËÆ§‰ø°ÊÅØ', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Production Key',
        status: 'ACTIVE',
      }

      const deletedKey = {
        ...existingKey,
        status: 'DELETED',
        deletedAt: new Date(),
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockResolvedValue({ success: true })
      ;(prisma.apiKey.update as jest.Mock).mockResolvedValue(deletedKey)

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(data).toHaveProperty('success', true)
      expect(data).toHaveProperty('message')
      expect(data.message).toContain('Â∑≤Âà†Èô§')
      expect(data).toHaveProperty('deletedKey')
      expect(data.deletedKey).toHaveProperty('id', mockKeyId)
      expect(data.deletedKey).toHaveProperty('name', 'Production Key')
    })
  })

  describe('‚ùå Â§±Ë¥•Âú∫ÊôØ - ËÆ§ËØÅÊéàÊùÉ', () => {
    it('Â∫îËØ•ÊãíÁªùÁº∫Â∞ëAuthorization headerÁöÑËØ∑Ê±Ç', async () => {
      // Arrange
      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(401)
      expect(data.error).toContain('Êú™ÁôªÂΩï')
    })

    it('Â∫îËØ•ÊãíÁªùÊó†ÊïàÁöÑJWT Token', async () => {
      // Arrange
      ;(jwt.verify as jest.Mock).mockImplementation(() => {
        throw new Error('Invalid token')
      })

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: 'Bearer invalid_token',
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(401)
      expect(data.error).toContain('TokenÊó†Êïà')
    })

    it('Â∫îËØ•ÊãíÁªùËøáÊúüÁöÑJWT Token', async () => {
      // Arrange
      ;(jwt.verify as jest.Mock).mockImplementation(() => {
        const error = new Error('Token expired')
        error.name = 'TokenExpiredError'
        throw error
      })

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: 'Bearer expired_token',
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(401)
      expect(data.error).toContain('TokenÂ∑≤ËøáÊúü')
    })

    it('Â∫îËØ•ÊãíÁªùÈùûaccessÁ±ªÂûãÁöÑToken', async () => {
      // Arrange
      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'refresh',
      })

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(401)
      expect(data.error).toContain('TokenÁ±ªÂûãÈîôËØØ')
    })
  })

  describe('‚ùå Â§±Ë¥•Âú∫ÊôØ - ÊùÉÈôêÈ™åËØÅ', () => {
    it('Â∫îËØ•ÊãíÁªùÂà†Èô§ÂÖ∂‰ªñÁî®Êà∑ÁöÑÂØÜÈí•', async () => {
      // Arrange
      const otherUserKey = {
        id: mockKeyId,
        userId: 'other_user_456',
        crsKeyId: mockCrsKeyId,
        name: 'Other User Key',
        status: 'ACTIVE',
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(otherUserKey)

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(403)
      expect(data.error).toContain('Êó†ÊùÉÈôê')
      expect(crsClient.deleteKey).not.toHaveBeenCalled()
      expect(prisma.apiKey.update).not.toHaveBeenCalled()
    })
  })

  describe('‚ùå Â§±Ë¥•Âú∫ÊôØ - ‰∏öÂä°ÈÄªËæë', () => {
    it('Â∫îËØ•ÊãíÁªùÂà†Èô§‰∏çÂ≠òÂú®ÁöÑÂØÜÈí•', async () => {
      // Arrange
      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(null)

      const request = new Request(
        'http://localhost:3000/api/keys/non_existent_key',
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, {
        params: { id: 'non_existent_key' },
      })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(404)
      expect(data.error).toContain('ÂØÜÈí•‰∏çÂ≠òÂú®')
    })
  })

  describe('‚ùå Â§±Ë¥•Âú∫ÊôØ - CRSÈõÜÊàê', () => {
    it('Â∫îËØ•Â§ÑÁêÜCRSÊúçÂä°‰∏çÂèØÁî®', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Test Key',
        status: 'ACTIVE',
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockRejectedValue(
        new Error('CRS service unavailable')
      )

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(503)
      expect(data.error).toContain('CRS')
      expect(prisma.apiKey.update).not.toHaveBeenCalled() // ‰∏çÂà†Èô§Êú¨Âú∞
    })

    it('Â∫îËØ•Â§ÑÁêÜCRSËøîÂõû‰∏öÂä°ÈîôËØØ', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Test Key',
        status: 'ACTIVE',
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockRejectedValue(
        Object.assign(new Error('Key not found in CRS'), {
          statusCode: 404,
        })
      )

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(404)
      expect(data.error).toContain('Key not found')
    })

    it('Â∫îËØ•Â§ÑÁêÜCRSÂà†Èô§ÊàêÂäü‰ΩÜÊú¨Âú∞Âà†Èô§Â§±Ë¥•', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Test Key',
        status: 'ACTIVE',
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockResolvedValue({ success: true })
      ;(prisma.apiKey.update as jest.Mock).mockRejectedValue(
        new Error('Database error')
      )

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(500)
      expect(data.error).toContain('Êú¨Âú∞Âà†Èô§Â§±Ë¥•')
      expect(data).toHaveProperty('crsDeleted', true) // Ê†áËÆ∞CRSÂ∑≤Âà†Èô§
    })

    it('CRSÂØÜÈí•‰∏çÂ≠òÂú®Êó∂Â∫îËØ•ÁªßÁª≠Âà†Èô§Êú¨Âú∞ËÆ∞ÂΩï', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Orphan Key',
        status: 'ACTIVE',
      }

      const deletedKey = {
        ...existingKey,
        status: 'DELETED',
        deletedAt: new Date(),
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockRejectedValue(
        Object.assign(new Error('Key not found'), {
          statusCode: 404,
        })
      )
      ;(prisma.apiKey.update as jest.Mock).mockResolvedValue(deletedKey)

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}?force=true`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(200)
      expect(data).toHaveProperty('success', true)
      expect(data).toHaveProperty('warning') // Ë≠¶ÂëäCRSÂØÜÈí•‰∏çÂ≠òÂú®
      expect(prisma.apiKey.update).toHaveBeenCalled() // ÁªßÁª≠Âà†Èô§Êú¨Âú∞
    })
  })

  describe('‚ùå Â§±Ë¥•Âú∫ÊôØ - Á≥ªÁªüÈîôËØØ', () => {
    it('Â∫îËØ•Â§ÑÁêÜÊï∞ÊçÆÂ∫ìÊü•ËØ¢ÈîôËØØ', async () => {
      // Arrange
      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockRejectedValue(
        new Error('Database connection failed')
      )

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(500)
      expect(data.error).toContain('Á≥ªÁªüÈîôËØØ')
    })
  })

  describe('üîí ÂÆâÂÖ®ÊÄßÊ£ÄÊü•', () => {
    it('Â∫îËØ•È™åËØÅÁî®Êà∑ÊùÉÈôê', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Test Key',
        status: 'ACTIVE',
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockResolvedValue({ success: true })
      ;(prisma.apiKey.update as jest.Mock).mockResolvedValue(existingKey)

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      await DELETE(request, { params: { id: mockKeyId } })

      // Assert
      expect(prisma.apiKey.findUnique).toHaveBeenCalledWith({
        where: { id: mockKeyId },
      })
      // È™åËØÅÂØÜÈí•ÂΩíÂ±û
      expect(existingKey.userId).toBe(mockUserId)
    })

    it('Â∫îËØ•È™åËØÅJWTÁ≠æÂêç', async () => {
      // Arrange
      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: 'Bearer tampered_token',
          },
        }
      )

      // Act
      await DELETE(request, { params: { id: mockKeyId } })

      // Assert
      expect(jwt.verify).toHaveBeenCalledWith(
        'tampered_token',
        process.env.JWT_SECRET
      )
    })

    it('Âà†Èô§Êìç‰ΩúÂ∫îËØ•ËÆ∞ÂΩïÂÆ°ËÆ°Êó•Âøó', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Important Key',
        status: 'ACTIVE',
      }

      const deletedKey = {
        ...existingKey,
        status: 'DELETED',
        deletedAt: new Date(),
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockResolvedValue({ success: true })
      ;(prisma.apiKey.update as jest.Mock).mockResolvedValue(deletedKey)

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      const response = await DELETE(request, { params: { id: mockKeyId } })
      const data = await response.json()

      // Assert
      expect(response.status).toBe(200)
      expect(data).toHaveProperty('deletedKey')
      // Â∫îËØ•ÂåÖÂê´Âà†Èô§Êó∂Èó¥Êà≥Áî®‰∫éÂÆ°ËÆ°
      expect(deletedKey).toHaveProperty('deletedAt')
    })
  })

  describe('üìä Âà†Èô§Á≠ñÁï•', () => {
    it('ÈªòËÆ§Â∫îËØ•‰ΩøÁî®ËΩØÂà†Èô§', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Test Key',
        status: 'ACTIVE',
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockResolvedValue({ success: true })
      ;(prisma.apiKey.update as jest.Mock).mockResolvedValue(existingKey)

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      await DELETE(request, { params: { id: mockKeyId } })

      // Assert
      expect(prisma.apiKey.update).toHaveBeenCalled() // ËΩØÂà†Èô§
      expect(prisma.apiKey.delete).not.toHaveBeenCalled() // ‰∏çÁâ©ÁêÜÂà†Èô§
    })

    it('permanent=trueÊó∂Â∫îËØ•Ê∞∏‰πÖÂà†Èô§', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Test Key',
        status: 'ACTIVE',
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockResolvedValue({ success: true })
      ;(prisma.apiKey.delete as jest.Mock).mockResolvedValue(existingKey)

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}?permanent=true`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      await DELETE(request, { params: { id: mockKeyId } })

      // Assert
      expect(prisma.apiKey.delete).toHaveBeenCalled() // Ê∞∏‰πÖÂà†Èô§
      expect(prisma.apiKey.update).not.toHaveBeenCalled() // ‰∏çËΩØÂà†Èô§
    })

    it('ËΩØÂà†Èô§ÂêéÁöÑÂØÜÈí•‰∏çÂ∫îËØ•Âá∫Áé∞Âú®ÂàóË°®‰∏≠', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Test Key',
        status: 'ACTIVE',
      }

      const deletedKey = {
        ...existingKey,
        status: 'DELETED',
        deletedAt: new Date(),
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockResolvedValue({ success: true })
      ;(prisma.apiKey.update as jest.Mock).mockResolvedValue(deletedKey)

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      await DELETE(request, { params: { id: mockKeyId } })

      // Assert
      expect(deletedKey.status).toBe('DELETED')
      // ÊöóÁ§∫ÔºöÂêéÁª≠ÁöÑÂàóË°®Êü•ËØ¢Â∫îËØ•ËøáÊª§ÊéâDELETEDÁä∂ÊÄÅÁöÑÂØÜÈí•
    })
  })

  describe('üîÑ ‰∫ãÂä°Â§ÑÁêÜ', () => {
    it('Â∫îËØ•ÂÖàÂà†Èô§CRSÂØÜÈí•ÂÜçÂà†Èô§Êú¨Âú∞ËÆ∞ÂΩï', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Test Key',
        status: 'ACTIVE',
      }

      let crsDeletedFirst = false
      let localDeletedAfter = false

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockImplementation(async () => {
        crsDeletedFirst = true
        return { success: true }
      })
      ;(prisma.apiKey.update as jest.Mock).mockImplementation(async () => {
        if (crsDeletedFirst) {
          localDeletedAfter = true
        }
        return existingKey
      })

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      await DELETE(request, { params: { id: mockKeyId } })

      // Assert
      expect(crsDeletedFirst).toBe(true)
      expect(localDeletedAfter).toBe(true)
    })

    it('CRSÂà†Èô§Â§±Ë¥•Êó∂‰∏çÂ∫îËØ•Âà†Èô§Êú¨Âú∞ËÆ∞ÂΩï', async () => {
      // Arrange
      const existingKey = {
        id: mockKeyId,
        userId: mockUserId,
        crsKeyId: mockCrsKeyId,
        name: 'Test Key',
        status: 'ACTIVE',
      }

      ;(jwt.verify as jest.Mock).mockReturnValue({
        userId: mockUserId,
        type: 'access',
      })
      ;(prisma.apiKey.findUnique as jest.Mock).mockResolvedValue(existingKey)
      ;(crsClient.deleteKey as jest.Mock).mockRejectedValue(
        new Error('CRS error')
      )

      const request = new Request(
        `http://localhost:3000/api/keys/${mockKeyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${mockAccessToken}`,
          },
        }
      )

      // Act
      await DELETE(request, { params: { id: mockKeyId } })

      // Assert
      expect(prisma.apiKey.update).not.toHaveBeenCalled()
      expect(prisma.apiKey.delete).not.toHaveBeenCalled()
    })
  })
})
